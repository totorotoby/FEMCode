#=

1D scheme, with with lagragian first order basis functions on evenly spaced mesh.
Interpolation points are equal to element boundaries.

=#

# initial condition
f(x) = cos.(pi.*x)
g(t) = 0

function getFlux!(flux::Array{Float64}, previous::Array{Float64}, t::Float64, α::Float64, a::Float64)
    #=

    for the far left element, the flux on the left side is the boundary condition,
    and the flux on the right is normal.
    
    =#
    
    #count indexs into previous
    count = 0
    
    for i in range 1:length(flux)
        
        if i == 1
            flux[i] = g(t)
        elseif index == length(flux)
            flux[i] = previous[length(previous)]
        else
            u_plus = previous[count+1]
            u_minus = previous[count]
            avg = u_plus + u_minus/2
            jump = u_plus - u_minus
            f[i] = avg + a*(1-α)*jump
        end
        count += 2
    end     
end


function initalFlux!(flux::Array{Float64})

    count = 0
    for i in x
        if count == 0
            flux[1] = g(t)
        elseif count == length(flux)
            flux[length(flux)] = f(1)
        else
            v = f(i)
            flux[count] = v
            flux[count+1] = v
        end
        count += 2
    end
end

                 
function main()
    let

        #=

        Parameters

        =#
        #wave-speed
        a = 1
        #growth-speed?
        b = 0
        #flux parameter
        α = 1
        # Left side of the interval
        l = -1
        # Right side of the interval
        r = 1
        # Number of elements
        nk = 10
        # order of approximations
        np = 2
        # number of basis functions
        nb = nk + 1
        # Length of each element
        h = (r - l)/nk
        # elements as a range
        x = l:h:r


        #=

        Assembing matrices and vectors

        =#

        # M matrix
        M = zeros(np,np)
        M[1,1] = 2/3 * (h/2)
        M[2,1] = 1/3 * (h/2)
        M[1, 2] = 1/3 * (h/2)
        M[1, 1] = 2/3 * (h/2)

        # S matrix
        S = zeros(np,np)
        S[1,1] = 1/2 * (h/2)
        S[2,1] = -1/2 * (h/2)
        S[1, 2] = -1/2 * (h/2)
        S[2, 2] = 1/2 * (h/2)

        # Phi vectors
        phi_l = [1,0]
        phi_r = [0,1]
        
        # inital fluxes for each element: nk + 1
        flux = zeros(2*nk)
        initialFlux(flux)
        
    end
end


main()
